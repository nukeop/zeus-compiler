use std::fmt;

#[derive(Debug, PartialEq)]
pub enum Instruction {
    NOOP,
    MVIX,
    MVIY,
    MVIT,
    MVAX,
    MVAY,
    MVAT,
    MVXA,
    MVYA,
    MVTA,
    MVPA,
    ADDX,
    ADDY,
    ADDT,
    SUBX,
    SUBY,
    SUBT,
    COPY,
    CPID,
    CPIR,
    ADDI,
    SUBI,
    MULI,
    DIVI,
    MODI,
    SWIZ,
    ANDI,
    ORLI,
    XORI,
    NEGI,
    SHLI,
    SHRI,
    EQLS,
    GRTR,
    LESS,
    JUMP,
    TJMP,
    FJMP,
    RJMP,
    IJMP,
    BANK,
    RAND,
    WAIT,
    CLRS,
    LABEL
}

pub enum ArgType {
    None,
    U8,
    U16,
    U8U16,
    U8U8U16,
    U16U16,
    U16U16U16,
    String
}

impl Instruction {
    pub fn from_string(value: &str) -> Result<Instruction, &str> {
        match value.to_string().to_uppercase().as_str() {
            "NOOP" => Ok(Instruction::NOOP),
            "MVIX" => Ok(Instruction::MVIX),
            "MVIY" => Ok(Instruction::MVIY),
            "MVIT" => Ok(Instruction::MVIT),
            "MVAX" => Ok(Instruction::MVAX),
            "MVAY" => Ok(Instruction::MVAY),
            "MVAT" => Ok(Instruction::MVAT),
            "MVXA" => Ok(Instruction::MVXA),
            "MVYA" => Ok(Instruction::MVYA),
            "MVTA" => Ok(Instruction::MVTA),
            "MVPA" => Ok(Instruction::MVPA),
            "ADDX" => Ok(Instruction::ADDX),
            "ADDY" => Ok(Instruction::ADDY),
            "ADDT" => Ok(Instruction::ADDT),
            "SUBX" => Ok(Instruction::SUBX),
            "SUBY" => Ok(Instruction::SUBY),
            "SUBT" => Ok(Instruction::SUBT),
            "COPY" => Ok(Instruction::COPY),
            "CPID" => Ok(Instruction::CPID),
            "CPIR" => Ok(Instruction::CPIR),
            "ADDI" => Ok(Instruction::ADDI),
            "SUBI" => Ok(Instruction::SUBI),
            "MULI" => Ok(Instruction::MULI),
            "DIVI" => Ok(Instruction::DIVI),
            "MODI" => Ok(Instruction::MODI),
            "SWIZ" => Ok(Instruction::SWIZ),
            "ANDI" => Ok(Instruction::ANDI),
            "ORLI" => Ok(Instruction::ORLI),
            "XORI" => Ok(Instruction::XORI),
            "NEGI" => Ok(Instruction::NEGI),
            "SHLI" => Ok(Instruction::SHLI),
            "SHRI" => Ok(Instruction::SHRI),
            "EQLS" => Ok(Instruction::EQLS),
            "GRTR" => Ok(Instruction::GRTR),
            "LESS" => Ok(Instruction::LESS),
            "JUMP" => Ok(Instruction::JUMP),
            "TJMP" => Ok(Instruction::TJMP),
            "FJMP" => Ok(Instruction::FJMP),
            "RJMP" => Ok(Instruction::RJMP),
            "IJMP" => Ok(Instruction::IJMP),
            "BANK" => Ok(Instruction::BANK),
            "RAND" => Ok(Instruction::RAND),
            "WAIT" => Ok(Instruction::WAIT),
            "CLRS" => Ok(Instruction::CLRS),
            "LABEL" => Ok(Instruction::LABEL),
            _ => Err("Invalid instruction")
        }
    }

    pub fn get_arg_type(&self) -> ArgType {
        match self {
            NOOP => ArgType::None,
            MVIX => ArgType::U8,
            MVIY => ArgType::U8,
            MVIT => ArgType::U8,
            MVAX => ArgType::U16,
            MVAY => ArgType::U16,
            MVAT => ArgType::U16,
            MVXA => ArgType::U16,
            MVYA => ArgType::U16,
            MVTA => ArgType::U16,
            MVPA => ArgType::U16,
            ADDX => ArgType::U8,
            ADDY => ArgType::U8,
            ADDT => ArgType::U8,
            SUBX => ArgType::U8,
            SUBY => ArgType::U8,
            SUBT => ArgType::U8,
            COPY => ArgType::U8U16,
            CPID => ArgType::U16U16,
            CPIR => ArgType::U16U16,
            ADDI => ArgType::U16U16U16,
            SUBI => ArgType::U16U16U16,
            MULI => ArgType::U16U16U16,
            DIVI => ArgType::U16U16U16,
            MODI => ArgType::U16U16U16,
            SWIZ => ArgType::U16U16U16,
            ANDI => ArgType::U16U16U16,
            ORLI => ArgType::U16U16U16,
            XORI => ArgType::U16U16U16,
            NEGI => ArgType::U16U16,
            SHLI => ArgType::U16U16,
            SHRI => ArgType::U16U16,
            EQLS => ArgType::U16U16,
            GRTR => ArgType::U16U16,
            LESS => ArgType::U16U16,
            JUMP => ArgType::U16,
            TJMP => ArgType::U16,
            FJMP => ArgType::U16,
            RJMP => ArgType::U8U16,
            IJMP => ArgType::U16,
            BANK => ArgType::U8,
            RAND => ArgType::U8U8U16,
            WAIT => ArgType::None,
            CLRS => ArgType::None,
            LABEL=> ArgType::String,
            _ => ArgType::None
        }
    }
}

impl fmt::Display for Instruction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            NOOP => write!(f, "NOOP"),
            MVIX => write!(f, "MVIX"),
            MVIY => write!(f, "MVIY"),
            MVIT => write!(f, "MVIT"),
            MVAX => write!(f, "MVAX"),
            MVAY => write!(f, "MVAY"),
            MVAT => write!(f, "MVAT"),
            MVXA => write!(f, "MVXA"),
            MVYA => write!(f, "MVYA"),
            MVTA => write!(f, "MVTA"),
            MVPA => write!(f, "MVPA"),
            ADDX => write!(f, "ADDX"),
            ADDY => write!(f, "ADDY"),
            ADDT => write!(f, "ADDT"),
            SUBX => write!(f, "SUBX"),
            SUBY => write!(f, "SUBY"),
            SUBT => write!(f, "SUBT"),
            COPY => write!(f, "COPY"),
            CPID => write!(f, "CPID"),
            CPIR => write!(f, "CPIR"),
            ADDI => write!(f, "ADDI"),
            SUBI => write!(f, "SUBI"),
            MULI => write!(f, "MULI"),
            DIVI => write!(f, "DIVI"),
            MODI => write!(f, "MODI"),
            SWIZ => write!(f, "SWIZ"),
            ANDI => write!(f, "ANDI"),
            ORLI => write!(f, "ORLI"),
            XORI => write!(f, "XORI"),
            NEGI => write!(f, "NEGI"),
            SHLI => write!(f, "SHLI"),
            SHRI => write!(f, "SHRI"),
            EQLS => write!(f, "EQLS"),
            GRTR => write!(f, "GRTR"),
            LESS => write!(f, "LESS"),
            JUMP => write!(f, "JUMP"),
            TJMP => write!(f, "TJMP"),
            FJMP => write!(f, "FJMP"),
            RJMP => write!(f, "RJMP"),
            IJMP => write!(f, "IJMP"),
            BANK => write!(f, "BANK"),
            RAND => write!(f, "RAND"),
            WAIT => write!(f, "WAIT"),
            CLRS => write!(f, "CLRS"),
            LABEL => write!(f, "LABEL")
        }
    }
}

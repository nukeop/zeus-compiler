use std::fmt;

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum Instruction {
    NOOP,
    MVIX,
    MVIY,
    MVIT,
    MVAX,
    MVAY,
    MVAT,
    MVXA,
    MVYA,
    MVTA,
    MVPA,
    ADDX,
    ADDY,
    ADDT,
    SUBX,
    SUBY,
    SUBT,
    COPY,
    CPID,
    CPIR,
    ADDI,
    SUBI,
    MULI,
    DIVI,
    MODI,
    SWIZ,
    ANDI,
    ORLI,
    XORI,
    NEGI,
    SHLI,
    SHRI,
    EQLS,
    GRTR,
    LESS,
    JUMP,
    TJMP,
    FJMP,
    RJMP,
    IJMP,
    BANK,
    RAND,
    WAIT,
    CLRS
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum ArgType {
    None,
    U8,
    U16,
    U8U16,
    U8U8U16,
    U16U16,
    U16U16U16
}

impl Instruction {
    pub fn from_string(value: &str) -> Result<Instruction, &str> {
        match value.to_string().to_uppercase().as_str() {
            "NOOP" => Ok(Instruction::NOOP),
            "MVIX" => Ok(Instruction::MVIX),
            "MVIY" => Ok(Instruction::MVIY),
            "MVIT" => Ok(Instruction::MVIT),
            "MVAX" => Ok(Instruction::MVAX),
            "MVAY" => Ok(Instruction::MVAY),
            "MVAT" => Ok(Instruction::MVAT),
            "MVXA" => Ok(Instruction::MVXA),
            "MVYA" => Ok(Instruction::MVYA),
            "MVTA" => Ok(Instruction::MVTA),
            "MVPA" => Ok(Instruction::MVPA),
            "ADDX" => Ok(Instruction::ADDX),
            "ADDY" => Ok(Instruction::ADDY),
            "ADDT" => Ok(Instruction::ADDT),
            "SUBX" => Ok(Instruction::SUBX),
            "SUBY" => Ok(Instruction::SUBY),
            "SUBT" => Ok(Instruction::SUBT),
            "COPY" => Ok(Instruction::COPY),
            "CPID" => Ok(Instruction::CPID),
            "CPIR" => Ok(Instruction::CPIR),
            "ADDI" => Ok(Instruction::ADDI),
            "SUBI" => Ok(Instruction::SUBI),
            "MULI" => Ok(Instruction::MULI),
            "DIVI" => Ok(Instruction::DIVI),
            "MODI" => Ok(Instruction::MODI),
            "SWIZ" => Ok(Instruction::SWIZ),
            "ANDI" => Ok(Instruction::ANDI),
            "ORLI" => Ok(Instruction::ORLI),
            "XORI" => Ok(Instruction::XORI),
            "NEGI" => Ok(Instruction::NEGI),
            "SHLI" => Ok(Instruction::SHLI),
            "SHRI" => Ok(Instruction::SHRI),
            "EQLS" => Ok(Instruction::EQLS),
            "GRTR" => Ok(Instruction::GRTR),
            "LESS" => Ok(Instruction::LESS),
            "JUMP" => Ok(Instruction::JUMP),
            "TJMP" => Ok(Instruction::TJMP),
            "FJMP" => Ok(Instruction::FJMP),
            "RJMP" => Ok(Instruction::RJMP),
            "IJMP" => Ok(Instruction::IJMP),
            "BANK" => Ok(Instruction::BANK),
            "RAND" => Ok(Instruction::RAND),
            "WAIT" => Ok(Instruction::WAIT),
            "CLRS" => Ok(Instruction::CLRS),
            _ => Err("Invalid instruction")
        }
    }

    pub fn to_string(&self) -> &'static str {
        use self::Instruction::*;

        match self {
            NOOP => "NOOP",
            MVIX => "MVIX",
            MVIY => "MVIY",
            MVIT => "MVIT",
            MVAX => "MVAX",
            MVAY => "MVAY",
            MVAT => "MVAT",
            MVXA => "MVXA",
            MVYA => "MVYA",
            MVTA => "MVTA",
            MVPA => "MVPA",
            ADDX => "ADDX",
            ADDY => "ADDY",
            ADDT => "ADDT",
            SUBX => "SUBX",
            SUBY => "SUBY",
            SUBT => "SUBT",
            COPY => "COPY",
            CPID => "CPID",
            CPIR => "CPIR",
            ADDI => "ADDI",
            SUBI => "SUBI",
            MULI => "MULI",
            DIVI => "DIVI",
            MODI => "MODI",
            SWIZ => "SWIZ",
            ANDI => "ANDI",
            ORLI => "ORLI",
            XORI => "XORI",
            NEGI => "NEGI",
            SHLI => "SHLI",
            SHRI => "SHRI",
            EQLS => "EQLS",
            GRTR => "GRTR",
            LESS => "LESS",
            JUMP => "JUMP",
            TJMP => "TJMP",
            FJMP => "FJMP",
            RJMP => "RJMP",
            IJMP => "IJMP",
            BANK => "BANK",
            RAND => "RAND",
            WAIT => "WAIT",
            CLRS => "CLRS"
        }
    }

    pub fn get_arg_type(&self) -> ArgType {
        use self::Instruction::*;

        match self {
            NOOP => ArgType::None,
            MVIX => ArgType::U8,
            MVIY => ArgType::U8,
            MVIT => ArgType::U8,
            MVAX => ArgType::U16,
            MVAY => ArgType::U16,
            MVAT => ArgType::U16,
            MVXA => ArgType::U16,
            MVYA => ArgType::U16,
            MVTA => ArgType::U16,
            MVPA => ArgType::U16,
            ADDX => ArgType::U8,
            ADDY => ArgType::U8,
            ADDT => ArgType::U8,
            SUBX => ArgType::U8,
            SUBY => ArgType::U8,
            SUBT => ArgType::U8,
            COPY => ArgType::U8U16,
            CPID => ArgType::U16U16,
            CPIR => ArgType::U16U16,
            ADDI => ArgType::U16U16U16,
            SUBI => ArgType::U16U16U16,
            MULI => ArgType::U16U16U16,
            DIVI => ArgType::U16U16U16,
            MODI => ArgType::U16U16U16,
            SWIZ => ArgType::U16U16U16,
            ANDI => ArgType::U16U16U16,
            ORLI => ArgType::U16U16U16,
            XORI => ArgType::U16U16U16,
            NEGI => ArgType::U16U16,
            SHLI => ArgType::U16U16,
            SHRI => ArgType::U16U16,
            EQLS => ArgType::U16U16,
            GRTR => ArgType::U16U16,
            LESS => ArgType::U16U16,
            JUMP => ArgType::U16,
            TJMP => ArgType::U16,
            FJMP => ArgType::U16,
            RJMP => ArgType::U8U16,
            IJMP => ArgType::U16,
            BANK => ArgType::U8,
            RAND => ArgType::U8U8U16,
            WAIT => ArgType::None,
            CLRS => ArgType::None
        }
    }

    pub fn compile(&self) -> Vec<u8> {
        use self::Instruction::*;

        match self {
            NOOP => vec![0x00],
            MVIX => vec![0x01],
            MVIY => vec![0x02],
            MVIT => vec![0x03],
            MVAX => vec![0x04],
            MVAY => vec![0x05],
            MVAT => vec![0x06],
            MVXA => vec![0x07],
            MVYA => vec![0x08],
            MVTA => vec![0x09],
            MVPA => vec![0x0A],
            ADDX => vec![0x0B],
            ADDY => vec![0x0C],
            ADDT => vec![0x0D],
            SUBX => vec![0x0E],
            SUBY => vec![0x0F],
            SUBT => vec![0x10],
            COPY => vec![0x11],
            CPID => vec![0x12],
            CPIR => vec![0x13],
            ADDI => vec![0x14],
            SUBI => vec![0x15],
            MULI => vec![0x16],
            DIVI => vec![0x17],
            MODI => vec![0x18],
            SWIZ => vec![0x19],
            ANDI => vec![0x1A],
            ORLI => vec![0x1B],
            XORI => vec![0x1C],
            NEGI => vec![0x1D],
            SHLI => vec![0x1E],
            SHRI => vec![0x1F],
            EQLS => vec![0x20],
            GRTR => vec![0x21],
            LESS => vec![0x22],
            JUMP => vec![0x23],
            TJMP => vec![0x24],
            FJMP => vec![0x25],
            RJMP => vec![0x26],
            IJMP => vec![0x27],
            BANK => vec![0x28],
            RAND => vec![0x29],
            WAIT => vec![0x2A],
            CLRS => vec![0x2B]
        }
    }
}

impl fmt::Display for Instruction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.to_string())
    }
}
